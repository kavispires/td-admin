{"version":3,"file":"static/js/Playground.61c8c2fc.chunk.js","mappings":"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","sources":["toolKits/gridMap.ts","pages/PlaygroundContent.tsx","pages/Playground.jsx","../node_modules/antd/es/_util/gapSize.js","../node_modules/antd/es/space/context.js","../node_modules/antd/es/space/Item.js","../node_modules/antd/es/space/index.js"],"sourcesContent":["import { flatten, sample } from 'lodash';\n\nexport type GridMapOrigin = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center';\nexport type GridMapCellState = 'available' | 'used' | 'locked' | 'unavailable' | string;\nexport type GridMapAdjacency = 'any' | 'orthogonal' | 'diagonal' | 'surrounding';\n\n/**\n * TD GRID MAP TOOLKIT FUNCTIONS\n * Version 1.0.0\n */\n\n/**\n * Represents a cell in a grid with optional coordinates and state.\n */\nexport type SeedCell<TCellData> = {\n  /**\n   * The x-coordinate of the cell\n   */\n  x?: number;\n  /**\n   * The y-coordinate of the cell\n   */\n  y?: number;\n  /**\n   * The data contained in the cell\n   */\n  data: TCellData | null;\n  /**\n   * The state of the cell\n   */\n  state?: GridMapCellState;\n};\n\nexport type GridMapCellType<TCellData> = {\n  /**\n   * The unique identifier of the cell composed of its x and y coordinates\n   */\n  id: string;\n  /**\n   * The x-coordinate of the cell\n   */\n  x: number;\n  /**\n   * The y-coordinate of the cell\n   */\n  y: number;\n  /**\n   * The data contained in the cell\n   */\n  data: TCellData | null;\n  /**\n   * The state of the cell (it accepts an arbitrary string for custom states)\n   */\n  state: GridMapCellState;\n};\n\nexport type GridMapType<TCellData> = {\n  /**\n   * The width of the grid\n   */\n  width: number;\n  /**\n   * The height of the grid\n   **/\n  height: number;\n  /**\n   * The origin of the grid\n   **/\n  origin: GridMapOrigin;\n  /**\n   * The cells of the grid\n   **/\n  cells: GridMapCellType<TCellData | null>[];\n  /**\n   * The adjacency of the grid\n   * - 'any': any empty cell is available\n   * - 'surrounding': only cells surrounding used cells are available\n   * - 'orthogonal': only cells orthogonally adjacent to used cells are available\n   * - 'diagonal': only cells diagonally adjacent to used cells are available\n   **/\n  adjacency: GridMapAdjacency;\n};\n\nexport type GridMapOptions<TCellData> = {\n  /**\n   * The origin of the grid\n   */\n  origin?: GridMapOrigin;\n  /**\n   * The default data to populate the grid with\n   */\n  defaultData?: SeedCell<TCellData> | SeedCell<TCellData>[];\n  /**\n   * The adjacency of the grid\n   */\n  adjacency?: GridMapAdjacency;\n};\n\n/**\n * Creates a grid with specified width and height, and initializes cells with optional data and state.\n * @template TCellData - The type of data stored in each cell.\n * @param width - The number of columns in the grid.\n * @param height - The number of rows in the grid.\n * @param [options={}] - Optional configuration for the grid.\n * @param [options.origin='top-left'] - The origin point of the grid.\n * @param [options.adjacency='any'] - The initial adjacency state of the cells.\n * @param [options.defaultData] - Default data to initialize the cells.\n * @returns The created grid object.\n */\nfunction createGridMap<TCellData>(\n  width: number,\n  height: number,\n  options: GridMapOptions<TCellData> = {},\n): GridMapType<TCellData> {\n  const origin = options.origin || 'top-left';\n  const adjacency = options.adjacency || 'any';\n\n  // Create a flattened array of cells\n  const cells: GridMapCellType<TCellData>[] = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      cells.push({\n        id: composeCellId(x, y),\n        x,\n        y,\n        data: null,\n        state: adjacency === 'any' ? 'available' : 'unavailable',\n      });\n    }\n  }\n\n  // Apply default data to specific cells if provided\n  const defaultData = options.defaultData;\n  if (defaultData && Array.isArray(defaultData)) {\n    defaultData.forEach(({ x, y, data, state }) => {\n      const cell = cells.find((cell) => cell.x === x && cell.y === y);\n      if (cell) {\n        cell.data = data;\n        cell.state = state || 'used';\n      }\n    });\n  } else if (defaultData) {\n    cells.forEach((cell) => {\n      cell.data = defaultData.data;\n      cell.state = defaultData.state || 'used';\n    });\n  }\n\n  return { width, height, origin, cells, adjacency };\n}\n\n/**\n * Composes a unique identifier for a cell based on its x and y coordinates.\n * @param x - The x-coordinate of the cell.\n * @param y - The y-coordinate of the cell.\n * @returns The unique identifier of the cell.\n */\nfunction composeCellId(x: number, y: number): string {\n  return `${x}-${y}`;\n}\n\n/**\n * Parses a cell identifier into its x and y coordinates.\n * @param id - The unique identifier of the cell.\n * @returns An object containing the x and y coordinates of the cell.\n */\nfunction parseCellId(id: string): { x: number; y: number } {\n  const [x, y] = id.split('-').map(Number);\n  return { x, y };\n}\n\n/**\n * Retrieves the index of a cell in the grid based on its x and y coordinates.\n * @param grid - The grid containing the cell.\n * @param x - The x-coordinate of the cell.\n * @param y - The y-coordinate of the cell.\n * @returns The index of the cell in the grid.\n */\nfunction getCellIndex<TCellData = unknown>(grid: GridMapType<TCellData>, x: number, y: number): number {\n  return grid.width * y + x;\n}\n\n/**\n * Retrieves a cell from the grid based on the provided x and y coordinates.\n *\n * @template TCellData - The type of data stored in the cell.\n * @param grid - The grid from which to retrieve the cell.\n * @param x - The x-coordinate of the cell.\n * @param y - The y-coordinate of the cell.\n * @returns {GridMapCellType<TCellData> | null} - The cell at the specified coordinates, or null if no cell exists at those coordinates.\n */\nfunction getCellByCoordinates<TCellData>(\n  grid: GridMapType<TCellData>,\n  x: number,\n  y: number,\n): GridMapCellType<TCellData | null> | null {\n  return grid.cells.find((cell) => cell.x === x && cell.y === y) || null;\n}\n\n/**\n * Retrieves a cell from the grid using its unique identifier.\n *\n * @template TCellData - The type of data stored in the cell.\n * @param grid - The grid from which to retrieve the cell.\n * @param id - The unique identifier of the cell, formatted as \"x-y\".\n * @returns {GridMapCellType<TCellData> | null} - The cell corresponding to the given id, or null if no such cell exists.\n */\nfunction getCellById<TCellData>(\n  grid: GridMapType<TCellData>,\n  id: string,\n): GridMapCellType<TCellData | null> | null {\n  return grid.cells.find((cell) => cell.id === id) || null;\n}\n\n/**\n * Retrieves the origin cell of the grid based on the specified origin point.\n */\nfunction getOrigin<TCellData>(grid: GridMapType<TCellData>): GridMapCellType<TCellData | null> | null {\n  const { width, height, origin } = grid;\n\n  let originX: number;\n  let originY: number;\n\n  switch (origin) {\n    case 'top-left':\n      originX = 0;\n      originY = 0;\n      break;\n    case 'top-right':\n      originX = width - 1;\n      originY = 0;\n      break;\n    case 'bottom-left':\n      originX = 0;\n      originY = height - 1;\n      break;\n    case 'bottom-right':\n      originX = width - 1;\n      originY = height - 1;\n      break;\n    case 'center':\n      originX = Math.floor(width / 2);\n      originY = Math.floor(height / 2);\n      break;\n    default:\n      originX = 0;\n      originY = 0;\n  }\n\n  return getCellByCoordinates(grid, originX, originY);\n}\n\n/**\n * Retrieves the unique identifier of the origin cell in the grid.\n */\nfunction getOriginId<TCellData>(grid: GridMapType<TCellData>): string | null {\n  const origin = getOrigin(grid);\n  return origin ? origin.id : null;\n}\n\n/**\n * Retrieves the coordinates of available cells in a grid based on the specified adjacency criteria.\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid to search for available cells.\n * @param [adjacency] - The adjacency criteria for selecting cells.\n *   - 'any': Selects any available cell.\n *   - 'orthogonal': Selects cells that are orthogonally adjacent to used cells.\n *   - 'diagonal': Selects cells that are diagonally adjacent to used cells.\n *  - 'surrounding': Selects cells that are surrounding used cells.\n * @param cellState - The state of the cells to search for.\n * @param [adjacentCellState='used'] - The state of the adjacent cells to check against.\n * @returns An array of coordinates of the available cells.\n */\nfunction getAllAdjacentCoordinates<TCellData>(\n  grid: GridMapType<TCellData>,\n  adjacency?: GridMapAdjacency,\n  cellState?: GridMapCellState,\n  adjacentCellState: GridMapCellState = 'used',\n): { x: number; y: number }[] {\n  const availableCells: { x: number; y: number }[] = [];\n  const chosenAdjacency = adjacency || grid.adjacency;\n\n  for (let y = 0; y < grid.height; y++) {\n    for (let x = 0; x < grid.width; x++) {\n      const cell = getCellByCoordinates(grid, x, y);\n\n      if (cell && (cellState ? cell.state === cellState : true) && cell.data === null) {\n        if (chosenAdjacency === 'any') {\n          availableCells.push({ x, y });\n        } else if (\n          chosenAdjacency === 'surrounding' &&\n          _isSurroundingAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push({ x, y });\n        } else if (\n          chosenAdjacency === 'orthogonal' &&\n          _isOrthogonallyAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push({ x, y });\n        } else if (\n          chosenAdjacency === 'diagonal' &&\n          _isDiagonallyAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push({ x, y });\n        }\n      }\n    }\n  }\n\n  return availableCells;\n}\n\n/**\n * Retrieves the ids of cells in a grid based on the specified adjacency criteria.\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid to search for available cells.\n * @param [adjacency] - The adjacency criteria for selecting cells.\n *   - 'any': Selects any available cell.\n *   - 'orthogonal': Selects cells that are orthogonally adjacent to used cells.\n *   - 'diagonal': Selects cells that are diagonally adjacent to used cells.\n *  - 'surrounding': Selects cells that are surrounding used cells.\n * @param [cellState='available'] - The state of the cells to search for.\n * @param [adjacentCellState='used'] - The state of the adjacent cells to check against.\n * @returns An array of ids of the cells.\n */\nfunction getAllAdjacentIds(\n  grid: GridMapType<unknown>,\n  adjacency?: GridMapAdjacency,\n  cellState?: GridMapCellState,\n  adjacentCellState: GridMapCellState = 'used',\n): string[] {\n  const availableCells: string[] = [];\n  const chosenAdjacency = adjacency || grid.adjacency;\n\n  for (let y = 0; y < grid.height; y++) {\n    for (let x = 0; x < grid.width; x++) {\n      const cell = getCellByCoordinates(grid, x, y);\n\n      if (cell && (cellState ? cell.state === cellState : true) && cell.data === null) {\n        if (chosenAdjacency === 'any') {\n          availableCells.push(cell.id);\n        } else if (\n          chosenAdjacency === 'surrounding' &&\n          _isSurroundingAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push(cell.id);\n        } else if (\n          chosenAdjacency === 'orthogonal' &&\n          _isOrthogonallyAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push(cell.id);\n        } else if (\n          chosenAdjacency === 'diagonal' &&\n          _isDiagonallyAdjacentToUsed(grid, x, y, adjacentCellState)\n        ) {\n          availableCells.push(cell.id);\n        }\n      }\n    }\n  }\n\n  return availableCells;\n}\n\nconst ORTHOGONAL_OFFSETS = [\n  { dx: 0, dy: -1 },\n  { dx: 0, dy: 1 },\n  { dx: -1, dy: 0 },\n  { dx: 1, dy: 0 },\n];\nconst DIAGONAL_OFFSETS = [\n  { dx: -1, dy: -1 },\n  { dx: 1, dy: -1 },\n  { dx: -1, dy: 1 },\n  { dx: 1, dy: 1 },\n];\nconst SURROUNDING_OFFSETS = [\n  { dx: -1, dy: -1 },\n  { dx: 0, dy: -1 },\n  { dx: 1, dy: -1 },\n  { dx: -1, dy: 0 },\n  { dx: 1, dy: 0 },\n  { dx: -1, dy: 1 },\n  { dx: 0, dy: 1 },\n  { dx: 1, dy: 1 },\n];\n\nconst OFFSETS = {\n  orthogonal: ORTHOGONAL_OFFSETS,\n  diagonal: DIAGONAL_OFFSETS,\n  surrounding: SURROUNDING_OFFSETS,\n  any: SURROUNDING_OFFSETS,\n};\n\n/**\n * Retrieves the available cell IDs from the grid based on the specified adjacency.\n *\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid map containing cell data.\n * @param [adjacency] - Optional parameter specifying the adjacency rules for determining available cells.\n * @returns An array of available cell IDs.\n */\nfunction _isOrthogonallyAdjacentToUsed<TCellData>(\n  grid: GridMapType<TCellData>,\n  x: number,\n  y: number,\n  cellState: GridMapCellState,\n): boolean {\n  return ORTHOGONAL_OFFSETS.some(({ dx, dy }) => {\n    const nx = x + dx;\n    const ny = y + dy;\n    return _isWithinBounds(grid, nx, ny) && getCellByCoordinates(grid, nx, ny)?.state === cellState;\n  });\n}\n\n/**\n * Checks if a cell in the grid is diagonally adjacent to any cell that is marked as 'used'.\n *\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid to check within.\n * @param x - The x-coordinate of the cell to check.\n * @param y - The y-coordinate of the cell to check.\n * @returns - Returns true if the cell is diagonally adjacent to a 'used' cell, otherwise false.\n */\nfunction _isDiagonallyAdjacentToUsed<TCellData>(\n  grid: GridMapType<TCellData>,\n  x: number,\n  y: number,\n  cellState: GridMapCellState,\n): boolean {\n  return DIAGONAL_OFFSETS.some(({ dx, dy }) => {\n    const nx = x + dx;\n    const ny = y + dy;\n    return _isWithinBounds(grid, nx, ny) && getCellByCoordinates(grid, nx, ny)?.state === cellState;\n  });\n}\n\nfunction _isSurroundingAdjacentToUsed<TCellData>(\n  grid: GridMapType<TCellData>,\n  x: number,\n  y: number,\n  cellState: GridMapCellState = 'used',\n): boolean {\n  return SURROUNDING_OFFSETS.some(({ dx, dy }) => {\n    const nx = x + dx;\n    const ny = y + dy;\n    return _isWithinBounds(grid, nx, ny) && getCellByCoordinates(grid, nx, ny)?.state === cellState;\n  });\n}\n\n/**\n * Checks if the given coordinates (x, y) are within the bounds of the grid.\n *\n * @template TCellData - The type of data stored in the grid cells.\n * @param grid - The grid to check the bounds against.\n * @param x - The x-coordinate to check.\n * @param y - The y-coordinate to check.\n * @returns - Returns `true` if the coordinates are within the bounds of the grid, otherwise `false`.\n */\nfunction _isWithinBounds<TCellData>(grid: GridMapType<TCellData>, x: number, y: number): boolean {\n  return x >= 0 && x < grid.width && y >= 0 && y < grid.height;\n}\n\n/**\n * Retrieves all empty cells from the given grid.\n *\n * @template TCellData - The type of data stored in the grid cells.\n * @param grid - The grid from which to retrieve empty cells.\n * @returns An array of cells that contain null data.\n */\nfunction getEmptyCells<TCellData>(grid: GridMapType<TCellData>): GridMapCellType<TCellData | null>[] {\n  return flatten(grid.cells).filter((cell): cell is GridMapCellType<TCellData | null> => cell.data === null);\n}\n\n/**\n * Updates the data and state of a specific cell in the grid.\n *\n * @template TCellData - The type of data stored in the cell.\n * @param grid - The grid containing the cell to be updated.\n * @param id - The unique identifier of the cell to be updated.\n * @param newData - The new data to be set in the cell. If null, the cell's data will be cleared.\n * @param [state] - The new state to be set for the cell. If not provided, defaults to 'available' if newData is null, otherwise 'used'.\n * @returns - The updated grid.\n */\nfunction updateCell<TCellData>(\n  grid: GridMapType<TCellData>,\n  id: string,\n  newData: TCellData | null,\n  state?: GridMapCellState,\n): GridMapType<TCellData> {\n  const cell = getCellById(grid, id);\n\n  if (cell) {\n    // Update the cell's data and state\n    if (newData === null) {\n      cell.data = null;\n      cell.state = state || 'available';\n    } else {\n      cell.data = newData;\n      cell.state = cell.state === 'locked' ? 'locked' : state || 'used';\n    }\n\n    // Update surrounding cells based on grid adjacency\n    _updateSurroundingCells(grid, cell.x, cell.y);\n  }\n\n  return grid;\n}\n\nfunction _updateSurroundingCells<TCellData>(grid: GridMapType<TCellData>, x: number, y: number) {\n  const adjacency = grid.adjacency;\n\n  const updateIfEmpty = (nx: number, ny: number) => {\n    const cell = getCellByCoordinates(grid, nx, ny);\n    if (cell && cell.data === null && cell.state !== 'locked') {\n      cell.state = 'available';\n    }\n  };\n\n  const offsets = OFFSETS[adjacency];\n  offsets.forEach(({ dx, dy }) => updateIfEmpty(x + dx, y + dy));\n}\n\n/**\n * Updates the state of a cell in the grid identified by the given identifier.\n *\n * @template TCellData - The type of data stored in the grid cells.\n * @param grid - The grid containing the cell to update.\n * @param identifier - The identifier of the cell to update.\n * @param newState - The new state to set for the cell.\n * @returns The updated grid.\n */\nfunction updateCellState<TCellData>(\n  grid: GridMapType<TCellData>,\n  identifier: string,\n  newState: GridMapCellState,\n): GridMapType<TCellData> {\n  const cell: GridMapCellType<TCellData | null> | null = getCellById(grid, identifier);\n\n  if (cell) {\n    cell.state = newState;\n  }\n\n  return grid;\n}\n\n/**\n * Helper function to retrieve adjacent cell IDs based on grid adjacency.\n * Uses orthogonal offsets if grid adjacency is 'orthogonal',\n * or all offsets (including diagonals) if 'diagonal'.\n *\n * @template TCellData - The type of data stored in the grid cells.\n * @param grid - The grid object.\n * @param x - The x-coordinate of the cell.\n * @param y - The y-coordinate of the cell.\n * @returns {string[]} - Array of adjacent cell IDs.\n */\nfunction _getAdjacentIdsByCoordinate<TCellData>(\n  grid: GridMapType<TCellData>,\n  x: number,\n  y: number,\n): string[] {\n  const offsets = OFFSETS[grid.adjacency];\n\n  const adjacentIds: string[] = [];\n\n  for (const { dx, dy } of offsets) {\n    const nx = x + dx;\n    const ny = y + dy;\n    if (_isWithinBounds(grid, nx, ny)) {\n      const adjacentCell = getCellByCoordinates(grid, nx, ny);\n      if (adjacentCell) adjacentIds.push(adjacentCell.id);\n    }\n  }\n\n  return adjacentIds;\n}\n\nfunction getAdjacentIdsToCellId<TCellData>(\n  grid: GridMapType<TCellData>,\n  id: string,\n  adjacency: GridMapAdjacency,\n  cellState?: GridMapCellState,\n): string[] {\n  const { x, y } = parseCellId(id);\n  const offsets = OFFSETS[adjacency];\n\n  const adjacentIds: string[] = [];\n\n  for (const { dx, dy } of offsets) {\n    const nx = x + dx;\n    const ny = y + dy;\n    if (_isWithinBounds(grid, nx, ny)) {\n      const adjacentCell = getCellByCoordinates(grid, nx, ny);\n      if (adjacentCell && (cellState ? adjacentCell.state === cellState : true))\n        adjacentIds.push(adjacentCell.id);\n    }\n  }\n\n  return adjacentIds;\n}\n\n/**\n * Creates a path on the grid starting from a specified cell and extending to a specified length.\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid where the path will be created.\n * @param length - The desired length of the path.\n * @param startId - The starting cell's ID.\n * @param options - Optional parameters for the path generation.\n * @param options.endId - The optional endpoint cell's ID.\n * @param options.allowRepetition - Whether to allow cells to be visited multiple times.\n * @returns An object with the generated path ID and the path array of cell IDs.\n */\nfunction createPath<TCellData>(\n  grid: GridMapType<TCellData | null>,\n  length: number,\n  startId: string,\n  options: { endId?: string; allowRepetition?: boolean } = {},\n): { id: string; path: string[] } | null {\n  const { endId, allowRepetition = false } = options;\n  const path: string[] = [startId];\n  let currentId = startId;\n\n  for (let i = 1; i < length; i++) {\n    const currentCell = getCellById(grid, currentId);\n    if (!currentCell) break;\n\n    // Get adjacent cells (orthogonal only to avoid circular paths)\n    const adjacentIds = _getAdjacentIdsByCoordinate(grid, currentCell.x, currentCell.y);\n\n    // Filter out cells already in the path if repetition is not allowed\n    const validNextIds = adjacentIds.filter((id) => allowRepetition || !path.includes(id));\n    if (validNextIds.length === 0) break;\n\n    // Choose the next cell, prioritizing endId if it's the final step\n    const nextId =\n      i === length - 1 && endId && validNextIds.includes(endId) ? endId : sample(validNextIds) || null;\n\n    if (!nextId) break;\n\n    path.push(nextId);\n    currentId = nextId;\n  }\n\n  // Ensure path length and endpoint match requirements\n  if (path.length !== length || (endId && path[path.length - 1] !== endId)) {\n    return null; // Path couldn't meet requirements\n  }\n\n  return { id: path.join(';;'), path };\n}\n\n/**\n * Creates multiple unique paths on the grid using the createPath function.\n * @template TCellData - The type of data stored in each cell of the grid.\n * @param grid - The grid where the paths will be created.\n * @param numPaths - The number of unique paths to create.\n * @param startIds - An array of starting cell IDs for each path.\n * @param pathLength - The length of each path.\n * @param allowRepetition - Whether cells can be visited multiple times within paths.\n * @returns An array of path objects, each containing an id and the path array of cell IDs.\n */\nfunction createPaths<TCellData>(\n  grid: GridMapType<TCellData | null>,\n  numPaths: number,\n  startIds: string[],\n  pathLength: number,\n  allowRepetition = false,\n): { id: string; path: string[] }[] {\n  const paths: { id: string; path: string[] }[] = [];\n\n  for (let i = 0; i < numPaths; i++) {\n    const startId = startIds[i % startIds.length];\n    const newPath = createPath(grid, pathLength, startId, { allowRepetition });\n\n    // Ensure uniqueness of paths\n    if (newPath && !paths.some((p) => p.id === newPath.id)) {\n      paths.push(newPath);\n    } else {\n      i--; // Retry if path is not unique or couldn't be created\n    }\n  }\n\n  return paths;\n}\n\nexport const gridMapUtils = {\n  createGridMap,\n  getCellById,\n  getCellByCoordinates,\n  updateCell,\n  updateCellState,\n  getEmptyCells,\n  getOrigin,\n  getOriginId,\n  getAllAdjacentCoordinates,\n  getAllAdjacentIds,\n  getAdjacentIdsToCellId,\n  createPath,\n  createPaths,\n  composeCellId,\n  parseCellId,\n  getCellIndex,\n};\n","import { Space } from 'antd';\nimport { useMemo } from 'react';\nimport { gridMapUtils } from '../toolKits/gridMap';\n\nexport function PlaygroundContent() {\n  const grid = useMemo(() => {\n    const g = gridMapUtils.createGridMap<string>(7, 7, { origin: 'center', adjacency: 'surrounding' });\n    const originId = gridMapUtils.getOriginId(g);\n    console.log({ originId });\n    gridMapUtils.updateCell(g, originId ?? '', 'center');\n    gridMapUtils.updateCell(g, '4-4', 'here');\n    gridMapUtils.updateCell(g, '0-0', 'top', 'locked');\n    console.log(g);\n    return g;\n  }, []);\n\n  const getCellColor = (state: string) => {\n    switch (state) {\n      case 'available':\n        return 'green';\n      case 'unavailable':\n        return 'red';\n      case 'visited':\n        return 'blue';\n      case 'used':\n        return 'yellow';\n      default:\n        return 'inherit';\n    }\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      {grid.cells.map((cell) => (\n        <div\n          key={cell.id}\n          style={{ width: 50, height: 50, border: '1px solid black', color: getCellColor(cell.state) }}\n        >\n          {cell.data ?? cell.id}\n        </div>\n      ))}\n    </Space>\n  );\n}\n","import { Divider, Layout } from 'antd';\nimport { Header } from 'components/Layout/Header';\nimport { useTitle } from 'react-use';\nimport { PlaygroundContent } from './PlaygroundContent';\n\nfunction Playground() {\n  useTitle('Playground');\n\n  return (\n    <Layout>\n      <Header title=\"Playground\" />\n\n      <Divider />\n\n      <Layout.Content className=\"content\">\n        <PlaygroundContent />\n      </Layout.Content>\n    </Layout>\n  );\n}\n\nexport default Playground;\n","export function isPresetSize(size) {\n  return ['small', 'middle', 'large'].includes(size);\n}\nexport function isValidGapNumber(size) {\n  if (!size) {\n    // The case of size = 0 is deliberately excluded here, because the default value of the gap attribute in CSS is 0, so if the user passes 0 in, we can directly ignore it.\n    return false;\n  }\n  return typeof size === 'number' && !Number.isNaN(size);\n}","import React from 'react';\nexport const SpaceContext = /*#__PURE__*/React.createContext({\n  latestIndex: 0\n});\nexport const SpaceContextProvider = SpaceContext.Provider;","\"use client\";\n\nimport * as React from 'react';\nimport { SpaceContext } from './context';\nconst Item = _ref => {\n  let {\n    className,\n    index,\n    children,\n    split,\n    style\n  } = _ref;\n  const {\n    latestIndex\n  } = React.useContext(SpaceContext);\n  if (children === null || children === undefined) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n    className: className,\n    style: style\n  }, children), index < latestIndex && split && /*#__PURE__*/React.createElement(\"span\", {\n    className: `${className}-split`\n  }, split));\n};\nexport default Item;","\"use client\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport { isPresetSize, isValidGapNumber } from '../_util/gapSize';\nimport { ConfigContext } from '../config-provider';\nimport Compact from './Compact';\nimport { SpaceContextProvider } from './context';\nimport Item from './Item';\nimport useStyle from './style';\nexport { SpaceContext } from './context';\nconst InternalSpace = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a, _b, _c;\n  const {\n    getPrefixCls,\n    space,\n    direction: directionConfig\n  } = React.useContext(ConfigContext);\n  const {\n      size = (_a = space === null || space === void 0 ? void 0 : space.size) !== null && _a !== void 0 ? _a : 'small',\n      align,\n      className,\n      rootClassName,\n      children,\n      direction = 'horizontal',\n      prefixCls: customizePrefixCls,\n      split,\n      style,\n      wrap = false,\n      classNames: customClassNames,\n      styles\n    } = props,\n    otherProps = __rest(props, [\"size\", \"align\", \"className\", \"rootClassName\", \"children\", \"direction\", \"prefixCls\", \"split\", \"style\", \"wrap\", \"classNames\", \"styles\"]);\n  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];\n  const isPresetVerticalSize = isPresetSize(verticalSize);\n  const isPresetHorizontalSize = isPresetSize(horizontalSize);\n  const isValidVerticalSize = isValidGapNumber(verticalSize);\n  const isValidHorizontalSize = isValidGapNumber(horizontalSize);\n  const childNodes = toArray(children, {\n    keepEmpty: true\n  });\n  const mergedAlign = align === undefined && direction === 'horizontal' ? 'center' : align;\n  const prefixCls = getPrefixCls('space', customizePrefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls);\n  const cls = classNames(prefixCls, space === null || space === void 0 ? void 0 : space.className, hashId, `${prefixCls}-${direction}`, {\n    [`${prefixCls}-rtl`]: directionConfig === 'rtl',\n    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,\n    [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,\n    [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize\n  }, className, rootClassName, cssVarCls);\n  const itemClassName = classNames(`${prefixCls}-item`, (_b = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _b !== void 0 ? _b : (_c = space === null || space === void 0 ? void 0 : space.classNames) === null || _c === void 0 ? void 0 : _c.item);\n  // Calculate latest one\n  let latestIndex = 0;\n  const nodes = childNodes.map((child, i) => {\n    var _a, _b;\n    if (child !== null && child !== undefined) {\n      latestIndex = i;\n    }\n    const key = (child === null || child === void 0 ? void 0 : child.key) || `${itemClassName}-${i}`;\n    return /*#__PURE__*/React.createElement(Item, {\n      className: itemClassName,\n      key: key,\n      index: i,\n      split: split,\n      style: (_a = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a !== void 0 ? _a : (_b = space === null || space === void 0 ? void 0 : space.styles) === null || _b === void 0 ? void 0 : _b.item\n    }, child);\n  });\n  const spaceContext = React.useMemo(() => ({\n    latestIndex\n  }), [latestIndex]);\n  // =========================== Render ===========================\n  if (childNodes.length === 0) {\n    return null;\n  }\n  const gapStyle = {};\n  if (wrap) {\n    gapStyle.flexWrap = 'wrap';\n  }\n  if (!isPresetHorizontalSize && isValidHorizontalSize) {\n    gapStyle.columnGap = horizontalSize;\n  }\n  if (!isPresetVerticalSize && isValidVerticalSize) {\n    gapStyle.rowGap = verticalSize;\n  }\n  return wrapCSSVar(/*#__PURE__*/React.createElement(\"div\", Object.assign({\n    ref: ref,\n    className: cls,\n    style: Object.assign(Object.assign(Object.assign({}, gapStyle), space === null || space === void 0 ? void 0 : space.style), style)\n  }, otherProps), /*#__PURE__*/React.createElement(SpaceContextProvider, {\n    value: spaceContext\n  }, nodes)));\n});\nconst Space = InternalSpace;\nSpace.Compact = Compact;\nif (process.env.NODE_ENV !== 'production') {\n  Space.displayName = 'Space';\n}\nexport default Space;"],"names":["composeCellId","x","y","parseCellId","id","split","map","Number","getCellByCoordinates","grid","cells","find","cell","getCellById","getOrigin","width","height","origin","originX","originY","Math","floor","ORTHOGONAL_OFFSETS","dx","dy","DIAGONAL_OFFSETS","SURROUNDING_OFFSETS","OFFSETS","orthogonal","diagonal","surrounding","any","_isOrthogonallyAdjacentToUsed","cellState","some","nx","ny","_isWithinBounds","state","_isDiagonallyAdjacentToUsed","_isSurroundingAdjacentToUsed","_getAdjacentIdsByCoordinate","offsets","adjacency","adjacentIds","adjacentCell","push","createPath","length","startId","options","endId","allowRepetition","path","currentId","i","currentCell","validNextIds","filter","includes","nextId","sample","join","gridMapUtils","createGridMap","data","defaultData","Array","isArray","forEach","updateCell","newData","updateIfEmpty","_updateSurroundingCells","updateCellState","identifier","newState","getEmptyCells","flatten","getOriginId","getAllAdjacentCoordinates","adjacentCellState","availableCells","chosenAdjacency","getAllAdjacentIds","getAdjacentIdsToCellId","createPaths","numPaths","startIds","pathLength","paths","newPath","p","getCellIndex","PlaygroundContent","useMemo","g","originId","console","log","getCellColor","direction","style","border","color","useTitle","Header","title","className","isPresetSize","size","isValidGapNumber","isNaN","SpaceContext","React","latestIndex","SpaceContextProvider","Provider","_ref","index","children","undefined","__rest","s","e","t","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","propertyIsEnumerable","InternalSpace","props","ref","_a","_b","_c","getPrefixCls","space","directionConfig","ConfigContext","align","rootClassName","prefixCls","customizePrefixCls","wrap","classNames","customClassNames","styles","otherProps","horizontalSize","verticalSize","isPresetVerticalSize","isPresetHorizontalSize","isValidVerticalSize","isValidHorizontalSize","childNodes","toArray","keepEmpty","mergedAlign","wrapCSSVar","hashId","cssVarCls","useStyle","cls","itemClassName","item","nodes","child","key","Item","spaceContext","gapStyle","flexWrap","columnGap","rowGap","assign","value","Space","Compact"],"sourceRoot":""}