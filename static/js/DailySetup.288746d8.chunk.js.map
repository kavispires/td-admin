{"version":3,"file":"static/js/DailySetup.288746d8.chunk.js","mappings":"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","sources":["components/Common/ResponseState.tsx","components/Common/SectionTitle.tsx","components/Common/TransparentButton.tsx","components/Common/FilterEntries.tsx","components/Daily/CanvasSVG.tsx","components/Daily/DataPopulation.tsx","components/Daily/SideFilters.tsx","pages/DailySetup.tsx","../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/react-query/src/useQueries.ts"],"sourcesContent":["import { Form, Tag } from 'antd';\nimport { SiderContent } from 'components/Layout';\n\ntype TagStateProps = {\n  /**\n   * The data is loading\n   */\n  isLoading: boolean;\n  /**\n   * The data hasn't run a query yet\n   */\n  isIdle?: boolean;\n  /**\n   * The data has an error\n   */\n  isError?: boolean;\n  /**\n   * The data has an error\n   */\n  error?: ResponseError;\n  /**\n   * The data has been modified\n   */\n  isDirty?: boolean;\n  /**\n   * There is a response\n   */\n  hasResponseData: boolean;\n};\n\nexport function TagState({ isLoading, isIdle, error, isDirty, isError, hasResponseData }: TagStateProps) {\n  if (isIdle) return <Tag>No Data yet</Tag>;\n  if (isLoading) return <Tag color=\"blue\">Loading...</Tag>;\n  if (error || isError) return <Tag color=\"red\">Error</Tag>;\n  if (isDirty) return <Tag color=\"orange\">Modified</Tag>;\n  if (hasResponseData) return <Tag color=\"green\">Loaded</Tag>;\n  return <Tag>No Data</Tag>;\n}\n\nexport function ResponseState(props: TagStateProps) {\n  return (\n    <SiderContent>\n      <Form.Item label=\"Status\">\n        <TagState {...props} />\n      </Form.Item>\n    </SiderContent>\n  );\n}\n","import { Typography } from 'antd';\nimport { TitleProps } from 'antd/lib/typography/Title';\n\nexport function SectionTitle({ children, level, ...rest }: TitleProps) {\n  return (\n    <Typography.Title level={level ?? 3} {...rest}>\n      {children}\n    </Typography.Title>\n  );\n}\n","import clsx from 'clsx';\nimport { ReactNode } from 'react';\n\ninterface TransparentButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  /**\n   * The content of the button\n   */\n  children: ReactNode;\n  /**\n   * Flag indicating if the button is on its active state\n   */\n  active?: boolean;\n  /**\n   * Custom active class\n   */\n  activeClass?: string;\n  /**\n   * Optional custom class name\n   */\n  className?: string;\n  /**\n   * Behavior when the mouse hovers the button (default: scale)\n   */\n  hoverType?: 'scale' | 'sepia';\n}\n\n/**\n * Transparent button that has all the functionality of a button but no visible styling\n */\nexport const TransparentButton = ({\n  children,\n  active = false,\n  activeClass = '',\n  className = '',\n  hoverType = 'scale',\n  ...rest\n}: TransparentButtonProps) => {\n  return (\n    <button\n      className={clsx(\n        'transparent-button',\n        `transparent-button--${hoverType}`,\n        active && (activeClass || 'transparent-button--active'),\n        className\n      )}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n","import { Form, InputNumber, Segmented, Select, Switch, Tooltip } from 'antd';\nimport { SegmentedValue } from 'antd/es/segmented';\nimport { ReactNode } from 'react';\n\ntype StrOrNum = string | number;\n\ntype FilterSelectProps = {\n  label: ReactNode;\n  value: string | number;\n  onChange: (value: any) => void;\n  options: { value: StrOrNum; label: StrOrNum }[] | StrOrNum[];\n  placeholder?: string;\n};\n\nexport function FilterSelect({ label, value, onChange, options, placeholder }: FilterSelectProps) {\n  return (\n    <Form.Item label={label}>\n      <Select style={{ minWidth: '150px' }} onChange={onChange} value={value}>\n        {placeholder && (\n          <Select.Option value={''} disabled>\n            placeholder\n          </Select.Option>\n        )}\n        {options.map((entry) =>\n          typeof entry === 'object' ? (\n            <Select.Option key={`${label}-${entry.value}`} value={entry.value}>\n              {entry.label}\n            </Select.Option>\n          ) : (\n            <Select.Option key={`${label}-${entry}`} value={entry}>\n              {entry}\n            </Select.Option>\n          )\n        )}\n      </Select>\n    </Form.Item>\n  );\n}\n\ntype FilterNumberProps = {\n  label: ReactNode;\n  value: number;\n  onChange: (value: number) => void;\n  min?: number;\n  max?: number;\n  step?: number;\n};\n\nexport function FilterNumber({ label, value, onChange, min = 0, max = 100, step }: FilterNumberProps) {\n  return (\n    <Form.Item label={label}>\n      <InputNumber\n        min={min}\n        max={max}\n        value={value}\n        onChange={(v) => onChange(v ?? max)}\n        style={{ minWidth: '150px', width: '100%' }}\n        step={step}\n      />\n    </Form.Item>\n  );\n}\n\ntype FilterSwitchProps = {\n  label: ReactNode;\n  value: boolean;\n  onChange: (value: boolean) => void;\n  className?: string;\n  disabled?: boolean;\n};\n\nexport function FilterSwitch({ label, value, onChange, className, disabled }: FilterSwitchProps) {\n  return (\n    <Form.Item label={label} valuePropName=\"checked\" className={className}>\n      <Switch checked={value} onChange={onChange} size=\"small\" disabled={disabled} />\n    </Form.Item>\n  );\n}\n\ntype FilterSegmentsProps = {\n  label: ReactNode;\n  value?: string;\n  onChange: (mode: SegmentedValue) => void;\n  options: { value: string; title: string; icon: ReactNode }[];\n};\n\nexport function FilterSegments({ value, label, onChange, options }: FilterSegmentsProps) {\n  return (\n    <Form.Item label={label}>\n      <Segmented\n        block\n        value={value}\n        onChange={onChange}\n        options={options.map((option) => ({\n          label: <Tooltip title={option.title}>{option.icon}</Tooltip>,\n          value: option.value,\n        }))}\n      />\n    </Form.Item>\n  );\n}\n","/**\n * Builds paths from canvas lines\n * @param lines\n * @returns\n */\nconst getPathFromKonvaLines = (lines: number[][]) => {\n  const result = lines.map((lineArr) => {\n    let path = '';\n    for (let x = 0, y = 1; y < lineArr.length; x += 2, y += 2) {\n      if (lineArr[x + 2] && lineArr[y + 2]) {\n        path += `M${lineArr[x]},${lineArr[y]} L${lineArr[x + 2]},${lineArr[y + 2]}`;\n      }\n    }\n\n    return path;\n  });\n\n  return result;\n};\n\ntype CanvasSVGProps = {\n  /**\n   * The stringified svg path\n   */\n  drawing: string;\n  /**\n   * Optional custom class name\n   */\n  className?: string;\n  /**\n   * The width of the canvas (default: 500)\n   */\n  width?: number;\n  /**\n   * The height of the canvas (default: 500)\n   */\n  height?: number;\n  /**\n   * Size of the stroke. Default: medium\n   */\n  strokeWidth?: 'small' | 'medium' | 'large';\n  /**\n   * Custom view box size (default: '0 0 500')\n   */\n  viewBox?: string;\n};\n\nexport const CanvasSVG = ({\n  drawing = '',\n  className = '',\n  width = 250,\n  height,\n  strokeWidth = 'medium',\n  viewBox = '0 0 500 500',\n}: CanvasSVGProps) => {\n  const konvaLines = JSON.parse(drawing);\n  const paths = getPathFromKonvaLines(konvaLines);\n\n  const strokeWidthBySize =\n    {\n      small: 3,\n      medium: 5,\n      large: 7,\n    }?.[strokeWidth] ?? 5;\n\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox={viewBox}\n      overflow=\"hidden\"\n      className={className}\n      style={{ width: `${width}px`, height: `${height || width}px` }}\n    >\n      <defs />\n      {paths.map((path, index) => (\n        <path\n          key={`${drawing}-${index}`}\n          d={path}\n          fill=\"none\"\n          stroke=\"#000\"\n          strokeWidth={strokeWidthBySize}\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          strokeMiterlimit=\"10\"\n        />\n      ))}\n    </svg>\n  );\n};\n","// Ant Design Resources\nimport { TableColumnsType, Table, Button, Flex, Space } from 'antd';\n// Components\n\nimport { UseLoadDailySetup, useSaveDailySetup } from './hooks';\n\nimport { DailyEntry } from './utils/types';\nimport { CanvasSVG } from 'components/Daily/CanvasSVG';\nimport { ArteRuimCard } from 'types';\n\ntype DataPopulationProps = {\n  language: string;\n  dataLoad: UseLoadDailySetup;\n};\n\nexport function DataPopulation({ language, dataLoad }: DataPopulationProps) {\n  const queryLanguage = language as Language;\n\n  const columns: TableColumnsType<DailyEntry> = [\n    {\n      title: 'Id',\n      dataIndex: 'id',\n      key: 'id',\n    },\n    {\n      title: 'Arte Ruim',\n      dataIndex: 'arte-ruim',\n      key: 'arte-ruim',\n      render: ({ number, cardId, text, drawings }) => {\n        return (\n          <Space direction=\"vertical\">\n            <Space>\n              <span>#{number}</span>\n              <span>CardId: {cardId}</span>\n              <span>Count: {drawings.length}</span>\n            </Space>\n            <div>\n              \"\n              {text\n                .split('')\n                .map((l: string, i: number) => (i < 2 || l === ' ' ? l : '⏹'))\n                .join('')}\n              \"\n            </div>\n            <Space>\n              {drawings.map((d: string) => (\n                <CanvasSVG key={d} drawing={d} width={75} height={75} className=\"canvas\" />\n              ))}\n            </Space>\n          </Space>\n        );\n      },\n    },\n    {\n      title: 'Aqui O',\n      dataIndex: 'aqui-o',\n      key: 'aqui-o',\n      render: ({ number, setId, title }) => {\n        return (\n          <Space direction=\"vertical\">\n            <span>#{number}</span>\n            <span>SetId: {setId}</span>\n            <span>Title: {title[language]}</span>\n          </Space>\n        );\n      },\n    },\n    {\n      title: 'Palavreado',\n      dataIndex: 'palavreado',\n      key: 'palavreado',\n      render: ({ number, words, letters, keyword }) => {\n        return (\n          <Space direction=\"vertical\">\n            <span>#{number}</span>\n            <span>Letters: {letters.length}</span>\n            <span>Keyword: {keyword}</span>\n            <Space direction=\"vertical\">\n              {words.map((word: string, index: number) => (\n                <span key={`${number}-${word}`}>\n                  {word\n                    .split('')\n                    .map((l: string, i: number) => (i === index || l === ' ' ? l : '⏹'))\n                    .join('')}\n                </span>\n              ))}\n            </Space>\n          </Space>\n        );\n      },\n    },\n    {\n      title: 'Filmaço',\n      dataIndex: 'filmaco',\n      key: 'filmaco',\n      render: ({ number, setId, year, title }) => {\n        return (\n          <Space direction=\"vertical\">\n            <span>#{number}</span>\n            <span>SetId: {setId}</span>\n            <span>Year: {year}</span>\n            <span>\n              Title:{' '}\n              {title\n                .split('')\n                .map((l: string, i: number) => (i < 1 || l === ' ' ? l : '⏹'))\n                .join('')}\n            </span>\n          </Space>\n        );\n      },\n    },\n    {\n      title: 'Artista',\n      dataIndex: 'artista',\n      key: 'artista',\n      render: ({ number, cards }) => {\n        return (\n          <Space direction=\"vertical\" style={{ maxHeight: 200, overflowY: 'auto' }}>\n            <span>#{number}</span>\n            {cards.map((card: ArteRuimCard, index: number) => (\n              <span key={`${card.id}-${index}`}>{card.text}</span>\n            ))}\n          </Space>\n        );\n      },\n    },\n  ];\n\n  const { save, isPending } = useSaveDailySetup(queryLanguage ?? 'pt');\n\n  return (\n    <div>\n      {dataLoad.isLoading && <div>Loading...</div>}\n      <Flex justify=\"space-between\" align=\"center\">\n        <h1>Total: {dataLoad.entries.length}</h1>\n        <Button\n          onClick={() => save(dataLoad.entries)}\n          loading={isPending}\n          disabled={(dataLoad.entries ?? []).length === 0}\n          type=\"primary\"\n          size=\"large\"\n        >\n          Save\n        </Button>\n      </Flex>\n      <Table columns={columns} dataSource={dataLoad.entries ?? []} />\n    </div>\n  );\n}\n","import { FilterSelect } from 'components/Common';\nimport { SiderContent } from 'components/Layout';\nimport { LANGUAGES } from 'utils/constants';\n\ntype SideFiltersProps = {\n  language: string;\n  setLanguage: (language: string) => void;\n  drawingsCount: number;\n  setDrawingsCount: (drawingsCount: number) => void;\n  batchSize: number;\n  setBatchSize: (batchSize: number) => void;\n};\n\nexport function SideFilters({\n  language,\n  setLanguage,\n  drawingsCount,\n  setDrawingsCount,\n  batchSize,\n  setBatchSize,\n}: SideFiltersProps) {\n  return (\n    <SiderContent>\n      <FilterSelect\n        label=\"Language\"\n        value={language}\n        onChange={setLanguage}\n        options={LANGUAGES}\n        placeholder=\"Select a language\"\n      />\n      <FilterSelect\n        label=\"Minimum Drawings\"\n        value={drawingsCount}\n        onChange={setDrawingsCount}\n        options={[2, 3, 4]}\n        placeholder=\"Select a number\"\n      />\n      <FilterSelect\n        label=\"Batch Size\"\n        value={batchSize}\n        onChange={setBatchSize}\n        options={[5, 15, 30, 45]}\n        placeholder=\"Select a number\"\n      />\n    </SiderContent>\n  );\n}\n","import { Layout, Typography } from 'antd';\nimport { DataPopulation } from 'components/Daily/DataPopulation';\nimport { SideFilters } from 'components/Daily/SideFilters';\nimport { useLoadDailySetup } from 'components/Daily/hooks';\nimport { DataLoadingWrapper } from 'components/DataLoadingWrapper';\nimport { PageLayout } from 'components/Layout';\nimport { PageSider } from 'components/Layout/PageSider';\nimport { ResponseState } from 'components/Common';\nimport { useState } from 'react';\n\nfunction DailySetup() {\n  const [language, setLanguage] = useState('');\n  const [drawingsCount, setDrawingsCount] = useState(2);\n  const [batchSize, setBatchSize] = useState(45);\n\n  const dataLoad = useLoadDailySetup(Boolean(language), language as Language, drawingsCount, batchSize);\n\n  return (\n    <PageLayout title=\"Daily Setup\">\n      <Layout hasSider>\n        <PageSider>\n          <ResponseState isLoading={dataLoad.isLoading} error={null} hasResponseData={!dataLoad.isLoading} />\n          <SideFilters\n            language={language}\n            setLanguage={setLanguage}\n            drawingsCount={drawingsCount}\n            setDrawingsCount={setDrawingsCount}\n            batchSize={batchSize}\n            setBatchSize={setBatchSize}\n          />\n        </PageSider>\n\n        <Layout.Content className=\"content\">\n          <DataLoadingWrapper\n            isLoading={dataLoad.isLoading}\n            error={null}\n            hasResponseData={!dataLoad.isLoading}\n          >\n            <Typography.Title level={2}>Data Population</Typography.Title>\n            <DataPopulation language={language} dataLoad={dataLoad} />\n          </DataLoadingWrapper>\n        </Layout.Content>\n      </Layout>\n    </PageLayout>\n  );\n}\n\nexport default DailySetup;\n","import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions>,\n    _options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    _options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult, (accessedProp) => {\n                // track property on all observers to ensure proper (synchronized) tracking (#7000)\n                matches.forEach((m) => {\n                  m.observer.trackProp(accessedProp)\n                })\n              })\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObservers = this.#observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.#client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: Array<QueryObserverMatch> =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const currentObserver = this.#observers.find(\n        (o) => o.options.queryHash === defaultedOptions.queryHash,\n      )\n      return (\n        currentObserver ?? new QueryObserver(this.#client, defaultedOptions)\n      )\n    }\n\n    const newOrReusedObservers: Array<QueryObserverMatch> =\n      unmatchedQueries.map((options) => {\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      })\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.#result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  SkipToken,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipToken\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipToken\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, any> | SkipToken\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipToken\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseQueryResult>\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions<\n            unknown,\n            Error,\n            unknown,\n            unknown,\n            QueryKey\n          >,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"names":["TagState","isLoading","isIdle","error","isDirty","isError","hasResponseData","color","ResponseState","props","label","SectionTitle","children","level","rest","TransparentButton","active","activeClass","className","hoverType","clsx","FilterSelect","value","onChange","options","placeholder","style","minWidth","disabled","map","entry","FilterNumber","min","max","step","v","width","FilterSwitch","valuePropName","checked","size","FilterSegments","block","option","title","icon","CanvasSVG","drawing","height","strokeWidth","viewBox","konvaLines","JSON","parse","paths","lineArr","path","x","y","length","strokeWidthBySize","small","medium","large","xmlns","overflow","index","d","fill","stroke","strokeLinecap","strokeLinejoin","strokeMiterlimit","DataPopulation","language","dataLoad","queryLanguage","columns","dataIndex","key","render","number","cardId","text","drawings","direction","split","l","i","join","setId","words","letters","keyword","word","year","cards","maxHeight","overflowY","card","id","save","isPending","useSaveDailySetup","justify","align","entries","onClick","loading","type","dataSource","SideFilters","setLanguage","drawingsCount","setDrawingsCount","batchSize","setBatchSize","LANGUAGES","useState","useLoadDailySetup","Boolean","hasSider","PageSider","DataLoadingWrapper","difference","array1","array2","filter","includes","QueriesObserver","Subscribable","constructor","client","queries","_options","super","this","setQueries","onSubscribe","listeners","forEach","observer","subscribe","result","onUnsubscribe","destroy","Set","notifyOptions","notifyManager","prevObservers","newObserverMatches","match","setOptions","defaultedQueryOptions","newObservers","newResult","getCurrentResult","hasIndexChange","some","hasListeners","getQueries","getCurrentQuery","getObservers","getOptimisticResult","combine","matches","r","observerResult","notifyOnChangeProps","trackResult","accessedProp","m","trackProp","input","replaceEqualDeep","prevObserversMap","Map","queryHash","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","get","matchedQueryHashes","unmatchedQueries","has","getObserver","currentObserver","find","o","QueryObserver","newOrReusedObservers","concat","sort","a","b","indexOf","array","copy","slice","replaceAt","listener","useQueries","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","React","opts","_optimisticResults","query","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","optimisticResult","getCombinedResult","onStoreChange","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","Promise","all","firstSingleResultWhichShouldThrow","getHasError","throwOnError","getQueryCache"],"sourceRoot":""}