{"version":3,"file":"static/js/5181.16f4aa7c.chunk.js","mappings":"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","sources":["components/Common/SectionTitle.tsx","components/Common/TransparentButton.tsx","components/Common/ResponseState.tsx","components/Daily/utils/games/daily-teoria-de-conjuntos.ts","components/Daily/utils/utils.ts","components/Items/Diagram/utils.ts","hooks/useGetFirebaseDoc.ts","hooks/useTDResource.ts"],"sourcesContent":["import { Typography } from 'antd';\nimport type { TitleProps } from 'antd/lib/typography/Title';\n\nexport function SectionTitle({ children, level, ...rest }: TitleProps) {\n  return (\n    <Typography.Title level={level ?? 3} {...rest}>\n      {children}\n    </Typography.Title>\n  );\n}\n","import clsx from 'clsx';\nimport type { ReactNode } from 'react';\n\ninterface TransparentButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  /**\n   * The content of the button\n   */\n  children: ReactNode;\n  /**\n   * Flag indicating if the button is on its active state\n   */\n  active?: boolean;\n  /**\n   * Custom active class\n   */\n  activeClass?: string;\n  /**\n   * Optional custom class name\n   */\n  className?: string;\n  /**\n   * Behavior when the mouse hovers the button (default: scale)\n   */\n  hoverType?: 'scale' | 'sepia';\n}\n\n/**\n * Transparent button that has all the functionality of a button but no visible styling\n */\nexport const TransparentButton = ({\n  children,\n  active = false,\n  activeClass = '',\n  className = '',\n  hoverType = 'scale',\n  ...rest\n}: TransparentButtonProps) => {\n  return (\n    <button\n      className={clsx(\n        'transparent-button',\n        `transparent-button--${hoverType}`,\n        active && (activeClass || 'transparent-button--active'),\n        className,\n      )}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n","import { Form, Tag } from 'antd';\nimport { SiderContent } from 'components/Layout';\n\ntype TagStateProps = {\n  /**\n   * The data is loading\n   */\n  isLoading: boolean;\n  /**\n   * The data hasn't run a query yet\n   */\n  isIdle?: boolean;\n  /**\n   * The data has an error\n   */\n  isError?: boolean;\n  /**\n   * The data has an error\n   */\n  error?: ResponseError;\n  /**\n   * The data has been modified\n   */\n  isDirty?: boolean;\n  /**\n   * There is a response\n   */\n  hasResponseData: boolean;\n};\n\nexport function TagState({ isLoading, isIdle, error, isDirty, isError, hasResponseData }: TagStateProps) {\n  if (isIdle) return <Tag>No Data yet</Tag>;\n  if (isLoading) return <Tag color=\"blue\">Loading...</Tag>;\n  if (error || isError) return <Tag color=\"red\">Error</Tag>;\n  if (isDirty) return <Tag color=\"orange\">Modified</Tag>;\n  if (hasResponseData) return <Tag color=\"green\">Loaded</Tag>;\n  return <Tag>No Data</Tag>;\n}\n\nexport function ResponseState(props: TagStateProps) {\n  return (\n    <SiderContent>\n      <Form.Item label=\"Status\">\n        <TagState {...props} />\n      </Form.Item>\n    </SiderContent>\n  );\n}\n","import { getIsThingOutdated, getLatestRuleUpdate } from 'components/Items/Diagram/utils';\nimport { cloneDeep, difference, intersection, sample, sampleSize, shuffle } from 'lodash';\nimport type { DailyDiagramItem, DailyDiagramRule } from 'types';\nimport type { DailyTeoriaDeConjuntosEntry, ParsedDailyHistoryEntry } from '../types';\nimport { getNextDay } from '../utils';\n\nconst SELECTION_SIZE = 8;\n\nexport const buildDailyTeoriaDeConjuntosGames = (\n  batchSize: number,\n  history: ParsedDailyHistoryEntry,\n  rules: Dictionary<DailyDiagramRule>,\n  things: Dictionary<DailyDiagramItem>,\n) => {\n  console.count('Creating Teoria de Conjuntos...');\n  let lastDate = history.latestDate;\n  const used: string[] = [...history.used];\n\n  const latestRuleUpdate = getLatestRuleUpdate(rules);\n\n  const thingsByRules = (() => {\n    const dict = Object.values(rules).reduce((acc: Record<string, string[]>, rule) => {\n      acc[rule.id] = [];\n      return acc;\n    }, {});\n\n    Object.values(things).forEach((entry) => {\n      // Only use things that are not outdated\n      if (!getIsThingOutdated(entry, latestRuleUpdate)) {\n        entry.rules.forEach((ruleId) => {\n          dict[ruleId].push(entry.itemId);\n        });\n      }\n    });\n    return dict;\n  })();\n\n  const entries: Dictionary<DailyTeoriaDeConjuntosEntry> = {};\n  for (let i = 0; i < batchSize; i++) {\n    const id = getNextDay(lastDate);\n\n    lastDate = id;\n    entries[id] = {\n      id,\n      type: 'teoria-de-conjuntos',\n      number: history.latestNumber + i + 1,\n      ...getRuleSet(things, thingsByRules, rules, used, latestRuleUpdate),\n    };\n  }\n  return entries;\n};\n\nfunction getRuleSet(\n  things: Dictionary<DailyDiagramItem>,\n  thingsByRules: Record<string, string[]>,\n  rules: Dictionary<DailyDiagramRule>,\n  used: string[],\n  latestRuleUpdate: number,\n) {\n  const availableThingsIds = shuffle(\n    Object.keys(things).filter(\n      (id) => !used.includes(id) && !getIsThingOutdated(things[id], latestRuleUpdate),\n    ),\n  );\n\n  // Get one random initial thing\n  const initialThingId = sample(availableThingsIds);\n  if (!initialThingId) throw new Error('No available things to choose from');\n  used.push(initialThingId);\n\n  const intersectingThing = {\n    id: initialThingId,\n    name: things[initialThingId].name,\n  };\n\n  // Group rules by type than get a random pair of rules of different types\n  const thingsRulesByType = things[initialThingId].rules.reduce((acc: Record<string, string[]>, ruleId) => {\n    const type = rules[ruleId].type;\n    if (!acc[type]) acc[type] = [];\n    acc[type].push(ruleId);\n    return acc;\n  }, {});\n  // Delete any rule with less than 2 rules\n  Object.keys(thingsRulesByType).forEach((type) => {\n    if (thingsRulesByType[type].length < 2) delete thingsRulesByType[type];\n  });\n\n  const twoRandomTypes = sampleSize(Object.keys(thingsRulesByType), 2);\n\n  if (twoRandomTypes.length !== 2) throw new Error('No types found for this thing');\n  const selectedRules = [\n    sample(thingsRulesByType[twoRandomTypes[0]]),\n    sample(thingsRulesByType[twoRandomTypes[1]]),\n  ];\n  if (!selectedRules[0] || !selectedRules[1]) throw new Error('No rules found for this thing');\n\n  const ruleId = [selectedRules[0], selectedRules[1]].sort().join('-');\n  used.push(ruleId);\n\n  const level = rules[selectedRules[0]].level + rules[selectedRules[1]].level - 1;\n\n  const availableThingsByRules = cloneDeep(thingsByRules);\n  // Removed the initial thing from the available things\n  delete availableThingsByRules[initialThingId];\n\n  const itemsOnlyInRule1 = shuffle(\n    difference(thingsByRules[selectedRules[0]], thingsByRules[selectedRules[1]]),\n  );\n\n  const itemsOnlyInRule2 = shuffle(\n    difference(thingsByRules[selectedRules[1]], thingsByRules[selectedRules[0]]),\n  );\n\n  const commonItems = shuffle(intersection(thingsByRules[selectedRules[0]], thingsByRules[selectedRules[1]]));\n\n  // Get one unique initial thing that only fits rule 1\n  const selectedInitialThingId1 = itemsOnlyInRule1.pop();\n  if (!selectedInitialThingId1) throw new Error('No only in rule 1 things to choose from');\n  const rule1 = {\n    id: selectedRules[0],\n    text: rules[selectedRules[0]].title,\n    level: rules[selectedRules[0]].level,\n    thing: {\n      id: selectedInitialThingId1,\n      name: things[selectedInitialThingId1].name,\n    },\n  };\n\n  // Get one unique initial thing that only fits rule 2\n  const selectedInitialThingId2 = itemsOnlyInRule2.pop();\n  if (!selectedInitialThingId2) throw new Error('No only in rule 2 things to choose from');\n  const rule2 = {\n    id: selectedRules[1],\n    text: rules[selectedRules[1]].title,\n    level: rules[selectedRules[1]].level,\n    thing: {\n      id: selectedInitialThingId2,\n      name: things[selectedInitialThingId2].name,\n    },\n  };\n\n  // Get up to 4 unique things that fit both rules, if possible\n  const sampleCommonThings = sampleSize(commonItems, SELECTION_SIZE / 2);\n  const sampleRule1Things = sampleSize(itemsOnlyInRule1, SELECTION_SIZE);\n  const sampleRule2Things = sampleSize(itemsOnlyInRule2, SELECTION_SIZE);\n  const answerSheet: Record<string, number> = {};\n  sampleCommonThings.forEach((id) => {\n    answerSheet[id] = 0;\n  });\n  sampleRule1Things.forEach((id) => {\n    answerSheet[id] = 1;\n  });\n  sampleRule2Things.forEach((id) => {\n    answerSheet[id] = 2;\n  });\n\n  // Sample 8 things among the options, shuffleAndCombine prevents from having the first 4 items from the same rule\n  const selectionIds = shuffleAndCombine(sampleCommonThings, sampleRule1Things, sampleRule2Things);\n\n  const selectedThings = selectionIds.map((id) => ({\n    id,\n    name: things[id].name,\n    rule: answerSheet[id],\n  }));\n\n  // Build title\n  const TITLES: Record<string, string> = {\n    contains: 'Inclusão',\n    starts: 'Inicialização',\n    ends: 'Terminação',\n    grammar: 'Gramática',\n    order: 'Sequência',\n    count: 'Contagem',\n    comparison: 'Comparação',\n    repetition: 'Repetição',\n  };\n\n  const title = [\n    TITLES?.[rules[rule1.id].type] ?? 'Desconhecido',\n    TITLES?.[rules[rule2.id].type] ?? 'Desconhecido',\n  ].join(' vs ');\n  const setId = [rule1.id, rule2.id].sort().join('::');\n\n  // Create the DailyTeoriaDeConjuntosEntry object\n  const entry: Omit<DailyTeoriaDeConjuntosEntry, 'id' | 'type' | 'number'> = {\n    title,\n    setId,\n    level,\n    rule1,\n    rule2,\n    intersectingThing,\n    things: selectedThings,\n  };\n  return entry;\n}\n\nfunction shuffleAndCombine(arr1: string[], arr2: string[], arr3: string[]) {\n  // Get the first 3 items from each array\n  const firstThreeArr1 = arr1.slice(0, 3);\n  const firstThreeArr2 = arr2.slice(0, 3);\n  const firstThreeArr3 = arr3.slice(0, 3);\n\n  // Combine and shuffle the first three items from each\n  let combined = sampleSize([...firstThreeArr1, ...firstThreeArr2, ...firstThreeArr3], SELECTION_SIZE);\n\n  // If the combined length is less than 9, gather remaining items\n  if (combined.length < SELECTION_SIZE) {\n    const remainingArr1 = arr1.slice(3);\n    const remainingArr2 = arr2.slice(3);\n    const remainingArr3 = arr3.slice(3);\n\n    const remaining = shuffle([...remainingArr1, ...remainingArr2, ...remainingArr3]);\n\n    // Append remaining items to the combined list\n    combined = [...combined, ...remaining];\n  }\n\n  return combined.slice(0, SELECTION_SIZE);\n}\n","import { sample } from 'lodash';\nimport moment from 'moment';\n\n/**\n * Returns the current date in the format 'YYYY-MM-DD'.\n *\n * @returns {string} The current date in 'YYYY-MM-DD' format.\n */\nexport function getToday(): string {\n  return moment().format('YYYY-MM-DD');\n}\n\n/**\n * Returns the date of yesterday in the format 'YYYY-MM-DD'.\n *\n * @returns {string} The date of yesterday in 'YYYY-MM-DD' format.\n */\nexport function getYesterday(): string {\n  return moment().subtract(1, 'days').format('YYYY-MM-DD');\n}\n\n/**\n * Calculates the next day based on the given date string.\n *\n * @param dateString - The date string in the format 'YYYY-MM-DD'.\n * @returns The next day in the format 'YYYY-MM-DD'.\n */\nexport function getNextDay(dateString: string): string {\n  const inputDate = moment(dateString, 'YYYY-MM-DD');\n  const nextDate = inputDate.add(1, 'days');\n\n  return nextDate.format('YYYY-MM-DD');\n}\n\n/**\n * Checks if a given date is a Saturday or Sunday.\n *\n * @param {string} dateString - The date in 'YYYY-MM-DD' format.\n * @returns {boolean} True if the date is a Saturday or Sunday, false otherwise.\n */\nexport function checkWeekend(dateString: string): boolean {\n  const date = moment(dateString, 'YYYY-MM-DD');\n  return [6, 0].includes(date.day()); // 0 represents Sunday and 6 represents Saturday in moment.js\n}\n\nconst THRESHOLD = 500;\nexport function getWordsWithUniqueLetters(words: string[]): string[] {\n  const selectedWords: string[] = [];\n  const usedLetters: BooleanDictionary = {};\n  let tries = 0;\n\n  while (selectedWords.length < 4 && tries < THRESHOLD) {\n    const word = sample(words) ?? '';\n    const splitWord = word.split('');\n    const isGood = splitWord.every((letter) => !usedLetters[letter]);\n    if (isGood) {\n      selectedWords.push(word);\n      splitWord.forEach((letter) => {\n        usedLetters[letter] = true;\n      });\n    } else {\n      tries++;\n    }\n  }\n  if (tries > THRESHOLD || selectedWords.length < 4) {\n    console.count('Could not find 4 words with unique letters');\n    while (selectedWords.length < 4) {\n      const word = sample(words) ?? '';\n      if (!selectedWords.includes(word)) {\n        selectedWords.push(word);\n      }\n    }\n  }\n\n  if (selectedWords.length < 4) {\n    console.error('Could not find 4 words with unique letters', selectedWords);\n  }\n\n  return selectedWords;\n}\n","import { memoize } from 'lodash';\nimport type { DailyDiagramItem, DailyDiagramRule } from 'types';\nimport { stringRemoveAccents } from 'utils';\n\nexport const SYLLABLE_SEPARATOR = '|';\nexport const LETTERS = 'abcdefghijklmnopqrstuvwxyz';\nexport const CONSONANTS = 'bcdfghjklmnpqrstvwxyz';\nexport const VOWELS = 'aeiou';\nexport const ACCENTS = /[áéíóúãẽĩõũâêîôûàèìòùäëïöü]/;\n\nconst cleanupWord = memoize((word: string) => {\n  return stringRemoveAccents(word).toLowerCase();\n});\n\nconst countLetters = (word: string) => {\n  return cleanupWord(word).length;\n};\n\nconst countVowels = (word: string) => {\n  return cleanupWord(word)\n    .split('')\n    .filter((letter) => VOWELS.includes(letter)).length;\n};\n\nconst countConsonants = (word: string) => {\n  return cleanupWord(word)\n    .split('')\n    .filter((letter) => CONSONANTS.includes(letter)).length;\n};\n\nconst countAccents = (word: string) => {\n  return word\n    .toLowerCase()\n    .split('')\n    .filter((letter) => ACCENTS.test(letter)).length;\n};\n\nconst countWords = (text: string) => {\n  return text.split(' ').length;\n};\n\nexport const verifiers: Record<string, (word: string) => boolean> = {\n  // The first two letters are in alphabetical order\n  'ddr-7-pt': (word: string) => {\n    return LETTERS.indexOf(cleanupWord(word)[0]) < LETTERS.indexOf(cleanupWord(word)[1]);\n  },\n  // has 4 or less letters\n  'ddr-8-pt': (word: string) => countLetters(word) <= 4,\n  // Has exactly 5 letters\n  'ddr-9-pt': (word: string) => countLetters(word) === 5,\n  // Has 6 letters\n  'ddr-10-pt': (word: string) => countLetters(word) === 6,\n  // Has between 7\n  'ddr-11-pt': (word: string) => countLetters(word) === 7,\n  // Has more than 8 letters\n  'ddr-12-pt': (word: string) => countLetters(word) > 7,\n  // Has more than 1 word\n  'ddr-13-pt': (word: string) => countWords(word) > 1,\n  // Has two or more different vowels\n  'ddr-14-pt': (word: string) => {\n    const vowels = cleanupWord(word)\n      .split('')\n      .filter((letter) => VOWELS.includes(letter));\n    return new Set(vowels).size >= 2;\n  },\n  // Has 4 or less unique letters\n  'ddr-15-pt': (word: string) => new Set(cleanupWord(word).split('')).size <= 4,\n  // Has more consonants than vowels\n  'ddr-16-pt': (word: string) => countConsonants(word) > countVowels(word),\n  // Has more vowels than consonants\n  'ddr-17-pt': (word: string) => countVowels(word) > countConsonants(word),\n  // The first letter is repeated at least once\n  'ddr-18-pt': (word: string) => {\n    const firstLetter = cleanupWord(word)[0];\n    return cleanupWord(word).slice(1).includes(firstLetter);\n  },\n  // has repeated letters\n  'ddr-19-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some((letter, index) =>\n        cleanupWord(word)\n          .slice(index + 1)\n          .includes(letter),\n      );\n  },\n  // has repeated vowels\n  'ddr-20-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some(\n        (letter, index) =>\n          VOWELS.includes(letter) &&\n          cleanupWord(word)\n            .slice(index + 1)\n            .includes(letter),\n      );\n  },\n  // has repeated consonants\n  'ddr-21-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some(\n        (letter, index) =>\n          CONSONANTS.includes(letter) &&\n          cleanupWord(word)\n            .slice(index + 1)\n            .includes(letter),\n      );\n  },\n  // has consecutive vowels\n  'ddr-22-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some((letter, index) => VOWELS.includes(letter) && VOWELS.includes(word[index + 1]));\n  },\n  // starts with letters from A to M\n  'ddr-23-pt': (word: string) => 'abcdefghijklm'.includes(cleanupWord(word)[0]),\n  // starts with letters from N to Z\n  'ddr-24-pt': (word: string) => 'nopqrstuvwxyz'.includes(cleanupWord(word)[0]),\n  // starts with a vowel\n  'ddr-25-pt': (word: string) => VOWELS.includes(cleanupWord(word)[0]),\n  // starts with a consonant\n  'ddr-26-pt': (word: string) => CONSONANTS.includes(cleanupWord(word)[0]),\n  // Double consecutive consonants\n  'ddr-27-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some((letter, index) => CONSONANTS.includes(letter) && word[index + 1] === letter);\n  },\n  // Has an A\n  'ddr-28-pt': (word: string) => cleanupWord(word).includes('a'),\n  // Has an E\n  'ddr-29-pt': (word: string) => cleanupWord(word).includes('e'),\n  // Has an U\n  'ddr-30-pt': (word: string) => cleanupWord(word).includes('u'),\n  // Has a Q or J\n  'ddr-31-pt': (word: string) => cleanupWord(word).includes('q'),\n  // Has a C or Ç\n  'ddr-32-pt': (word: string) => cleanupWord(word).includes('c') || cleanupWord(word).includes('ç'),\n  // Has an M or N followed by a consonant\n  'ddr-33-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some((letter, index) => {\n        if (['m', 'n'].includes(letter) && CONSONANTS.includes(word[index + 1])) {\n          return true;\n        }\n        return false;\n      });\n  },\n  // Has an H\n  'ddr-34-pt': (word: string) => cleanupWord(word).includes('h'),\n  // Has H preceded by a consonant\n  'ddr-35-pt': (word: string) => {\n    return cleanupWord(word)\n      .split('')\n      .some((letter, index) => {\n        if (letter === 'h' && CONSONANTS.includes(word[index - 1])) {\n          return true;\n        }\n        return false;\n      });\n  },\n  // Has K, W or Y\n  'ddr-36-pt': (word: string) =>\n    cleanupWord(word).includes('k') || cleanupWord(word).includes('w') || cleanupWord(word).includes('y'),\n  // Has an accent\n  'ddr-37-pt': (word: string) => countAccents(word) > 0,\n  // Ends with a vowel\n  'ddr-38-pt': (word: string) => {\n    return VOWELS.includes(cleanupWord(word).slice(-1));\n  },\n  // Ends with a consonant\n  'ddr-39-pt': (word: string) => CONSONANTS.includes(cleanupWord(word).slice(-1)),\n  // Ends with an S\n  'ddr-40-pt': (word: string) => cleanupWord(word).slice(-1) === 's',\n  // Has an I\n  'ddr-47-pt': (word: string) => cleanupWord(word).includes('i'),\n  // Has an O\n  'ddr-48-pt': (word: string) => cleanupWord(word).includes('o'),\n  // Has an X\n  'ddr-49-pt': (word: string) => cleanupWord(word).includes('x'),\n  // Has an J\n  'ddr-52-pt': (word: string) => cleanupWord(word).includes('j'),\n};\n\nexport const syllableDependencyVerifier: Record<\n  string,\n  (word: string, syllables: string, isAcronym: boolean) => boolean\n> = {\n  // Has 2 syllables\n  'ddr-3-pt': (word: string, syllables: string) =>\n    countWords(word) === 1 && syllables.split(SYLLABLE_SEPARATOR).length === 2,\n  // Has 3 syllables\n  'ddr-4-pt': (word: string, syllables: string) =>\n    countWords(word) === 1 && syllables.split(SYLLABLE_SEPARATOR).length === 3,\n  // Has 4 syllables\n  'ddr-22-pt': (word: string, syllables: string) =>\n    countWords(word) === 1 && syllables.split(SYLLABLE_SEPARATOR).length === 4,\n  // Has two consecutive vowels on the same syllable\n  'ddr-41-pt': (word: string, syllables: string) => {\n    return (\n      countWords(word) === 1 &&\n      syllables.split(SYLLABLE_SEPARATOR).some((syllable) => {\n        return syllable.split('').some((letter, index) => {\n          if (VOWELS.includes(letter) && VOWELS.includes(syllable[index + 1])) {\n            return true;\n          }\n          return false;\n        });\n      })\n    );\n  },\n  // Has two consecutive vowels on different syllables\n  'ddr-42-pt': (_: string, syllables: string) => {\n    return syllables.split(SYLLABLE_SEPARATOR).some((syllable, index) => {\n      if (index === 0) {\n        return false;\n      }\n      return syllable[0] === syllables.split(SYLLABLE_SEPARATOR)[index - 1].slice(-1);\n    });\n  },\n  // Single syllable word\n  'ddr-46-pt': (word: string, syllables: string, isAcronym: boolean) =>\n    countWords(word) === 1 && !isAcronym && syllables.split(SYLLABLE_SEPARATOR).length === 1,\n};\n\nexport const stressSyllableDependencyVerifier: Record<\n  string,\n  (word: string, syllables: string, stress: number) => boolean\n> = {\n  // The stress syllable is on the last syllable (oxitona)\n  'ddr-43-pt': (word: string, _, stress: number) => {\n    return countWords(word) === 1 && stress === 0;\n  },\n  // The stress syllable is on the second to last syllable (paroxitona)\n  'ddr-44-pt': (word: string, _, stress: number) => {\n    return countWords(word) === 1 && stress === 1;\n  },\n  // The stress syllable is on the third to last syllable (proparoxitona)\n  'ddr-45-pt': (word: string, _, stress: number) => {\n    return countWords(word) === 1 && stress === 2;\n  },\n};\n\nexport const getLatestRuleUpdate = (rules: Dictionary<DailyDiagramRule>) => {\n  return Object.values(rules).reduce((acc, rule) => {\n    return Math.max(acc, rule.updatedAt);\n  }, 0);\n};\n\nexport const getIsThingOutdated = (thing: DailyDiagramItem, latestRuleUpdate: number) => {\n  return latestRuleUpdate > thing.updatedAt;\n};\n\nconst checkIsVowel = (char: string) => VOWELS.includes(stringRemoveAccents(char));\nconst checkIsConsonant = (char: string) => CONSONANTS.includes(stringRemoveAccents(char));\nconst LMNRS = ['s', 'r', 'l', 'm', 'n'];\nconst DOUBLE_LETTERS = [\n  'rr',\n  'ss',\n  'st',\n  'sc',\n  'lm',\n  'ld',\n  'mp',\n  'mb',\n  'rn',\n  'rm',\n  'rt',\n  'rd',\n  'lt',\n  'ld',\n  'nt',\n  'nd',\n  'sp',\n  'ls',\n];\n/**\n * Guesses the separation of syllables in a given word.\n * @param word - The word for which to guess the syllables separation.\n * @returns The guessed syllables separation as a string.\n */\nexport const guessSyllablesSeparation = (word: string): string => {\n  let syllables: string[] = [];\n  let currentSyllable = '';\n\n  const stringWithoutAccents = stringRemoveAccents(word);\n\n  for (let i = 0; i < word.length; i++) {\n    const char = stringWithoutAccents[i];\n    // Space makes a syllable\n    if (char === ' ') {\n      syllables.push(currentSyllable);\n      currentSyllable = '';\n      continue;\n    }\n\n    // Hyphen makes a syllable\n    if (char === '-') {\n      syllables.push(`${currentSyllable}-`);\n      currentSyllable = '';\n      continue;\n    }\n\n    if (checkIsVowel(char) && i < stringWithoutAccents.length - 2) {\n      const nextChar = stringWithoutAccents[i + 1];\n      const nextNextChar = stringWithoutAccents[i + 2];\n      // If the next character is a consonant and the next next character is a consonant, the first pair is a syllable\n      if (LMNRS.includes(nextChar) && checkIsConsonant(nextNextChar)) {\n        currentSyllable += word[i] + word[i + 1];\n        i++; // Skip the next character\n        continue;\n      }\n    }\n\n    // Handle \"c\" followed by \"h\", \"r\", or \"l\"\n    if (\n      char === 'c' &&\n      i < stringWithoutAccents.length - 2 &&\n      ['h', 'r', 'l'].includes(stringWithoutAccents[i + 1]) &&\n      checkIsVowel(stringWithoutAccents[i + 2])\n    ) {\n      currentSyllable += word[i] + word[i + 1] + word[i + 2];\n      i += 2; // Skip the next two characters\n      continue;\n    }\n\n    // Handle \"l\" or \"n\" followed by \"h\"\n    if (\n      ['l', 'n'].includes(char) &&\n      i < stringWithoutAccents.length - 2 &&\n      stringWithoutAccents[i + 1] === 'h' &&\n      checkIsVowel(stringWithoutAccents[i + 2])\n    ) {\n      currentSyllable += word[i] + word[i + 1] + word[i + 2];\n      i += 2; // Skip the next two characters\n      continue;\n    }\n\n    // Handle consonant followed by vowel followed by consonant cluster\n    if (\n      checkIsConsonant(char) &&\n      i < stringWithoutAccents.length - 3 &&\n      checkIsVowel(stringWithoutAccents[i + 1]) &&\n      LMNRS.includes(stringWithoutAccents[i + 2]) &&\n      checkIsConsonant(stringWithoutAccents[i + 3])\n    ) {\n      currentSyllable += word[i] + word[i + 1] + word[i + 2];\n      i += 2; // Skip the next two characters\n      continue;\n    }\n\n    currentSyllable += word[i];\n\n    if (\n      checkIsVowel(char) &&\n      i < stringWithoutAccents.length - 1 &&\n      !checkIsVowel(stringWithoutAccents[i + 1]) &&\n      !['l', 'r', 'n'].includes(stringWithoutAccents[i + 1])\n    ) {\n      syllables.push(currentSyllable);\n      currentSyllable = '';\n    }\n  }\n\n  if (currentSyllable !== '') {\n    syllables.push(currentSyllable);\n  }\n\n  // As a final effort, if there are syllables with \"rr\" or \"ss\", split them but keep the characters. e.g. carro -> car:ro\n  syllables = syllables.map((syllable) => {\n    for (const doubleLetter of DOUBLE_LETTERS) {\n      if (syllable.includes(doubleLetter)) {\n        return syllable.split(doubleLetter).join(`${doubleLetter[0]}${SYLLABLE_SEPARATOR}${doubleLetter[1]}`);\n      }\n    }\n    return syllable;\n  });\n\n  return syllables.filter(Boolean).join(SYLLABLE_SEPARATOR);\n};\n\n/**\n * Separates the syllables of a given word.\n * @param word - The word to separate syllables from.\n * @returns The word with syllables separated by '|'.\n */\nexport function separateSyllables(word: string): string {\n  const syllablePattern =\n    /([^aeiouáéíóúâêîôûàèìòùãõäëïöüAEIOUÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÃÕÄËÏÖÜ]*[aeiouáéíóúâêîôûàèìòùãõäëïöüAEIOUÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÃÕÄËÏÖÜ]{1,3}[^aeiouáéíóúâêîôûàèìòùãõäëïöüAEIOUÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÃÕÄËÏÖÜ]*)(?=[^aeiouáéíóúâêîôûàèìòùãõäëïöüAEIOUÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÃÕÄËÏÖÜ]|$)/gi;\n\n  const proposed = word.replace(syllablePattern, '$1|').slice(0, -1);\n\n  return proposed.replace(/\\s/g, '');\n}\n","import { doc, getDoc } from 'firebase/firestore';\nimport { firestore } from 'services/firebase';\n\nimport { type QueryKey, type UseQueryOptions, useQuery } from '@tanstack/react-query';\nimport { getCurrentDateTime } from 'utils';\n\nexport function getDocQueryFunction<TQueryFnData>(path: string, docId: string) {\n  return async () => {\n    console.log(`%cQuerying ${path}/${docId} from firebase: ${getCurrentDateTime()}`, 'color: #f0f');\n    const docRef = doc(firestore, `${path}/${docId}`);\n    const querySnapshot = await getDoc(docRef);\n    return (querySnapshot.data() ?? {}) as TQueryFnData;\n  };\n}\n\nexport function useGetFirebaseDoc<TQueryFnData, TData = TQueryFnData>(\n  path: string,\n  docId: string,\n  options?: Omit<UseQueryOptions<any, Error, TData, QueryKey>, 'queryKey'>,\n) {\n  return useQuery<TQueryFnData, Error, TData, QueryKey>({\n    queryKey: ['firebase', path, docId],\n    queryFn: getDocQueryFunction<TQueryFnData>(path, docId),\n    ...options,\n  });\n}\n","import { isEmpty } from 'lodash';\n\nimport { useQuery } from '@tanstack/react-query';\n\nimport { useBaseUrl } from './useBaseUrl';\n\nexport function useTDResource<TData>(resourceName: string, enabled = true) {\n  const { getUrl } = useBaseUrl('resources');\n\n  const query = useQuery<Dictionary<TData>, ResponseError>({\n    queryKey: [resourceName],\n    queryFn: async () => {\n      const res = await fetch(getUrl(`${resourceName}.json`));\n      return (await res.json()) as Dictionary<TData>;\n    },\n    enabled,\n  });\n  const hasResponseData = !isEmpty(query.data);\n\n  return {\n    ...query,\n    data: query.data ?? ({} as Dictionary<TData>),\n    hasResponseData,\n  };\n}\n\nexport function useTDResourceNonCollection<TData>(resourceName: string, enabled = true) {\n  const { getUrl } = useBaseUrl('resources');\n\n  const query = useQuery<TData, ResponseError>({\n    queryKey: [resourceName],\n    queryFn: async () => {\n      const res = await fetch(getUrl(`${resourceName}.json`));\n      return (await res.json()) as TData;\n    },\n    enabled,\n  });\n  const hasResponseData = !isEmpty(query.data);\n\n  return {\n    ...query,\n    data: query.data,\n    hasResponseData,\n  };\n}\n"],"names":["SectionTitle","children","level","rest","TransparentButton","active","activeClass","className","hoverType","clsx","TagState","isLoading","isIdle","error","isDirty","isError","hasResponseData","color","ResponseState","props","label","buildDailyTeoriaDeConjuntosGames","batchSize","history","rules","things","console","count","lastDate","latestDate","used","latestRuleUpdate","getLatestRuleUpdate","thingsByRules","dict","Object","values","reduce","acc","rule","id","forEach","entry","getIsThingOutdated","ruleId","push","itemId","entries","i","getNextDay","type","number","latestNumber","getRuleSet","availableThingsIds","shuffle","keys","filter","includes","initialThingId","sample","Error","intersectingThing","name","thingsRulesByType","length","twoRandomTypes","sampleSize","selectedRules","sort","join","cloneDeep","itemsOnlyInRule1","difference","itemsOnlyInRule2","commonItems","intersection","selectedInitialThingId1","pop","rule1","text","title","thing","selectedInitialThingId2","rule2","sampleCommonThings","SELECTION_SIZE","sampleRule1Things","sampleRule2Things","answerSheet","selectedThings","arr1","arr2","arr3","firstThreeArr1","slice","firstThreeArr2","firstThreeArr3","combined","remainingArr1","remainingArr2","remainingArr3","remaining","shuffleAndCombine","map","TITLES","contains","starts","ends","grammar","order","comparison","repetition","setId","getYesterday","moment","subtract","format","dateString","add","checkWeekend","date","day","SYLLABLE_SEPARATOR","LETTERS","CONSONANTS","VOWELS","ACCENTS","cleanupWord","memoize","word","stringRemoveAccents","toLowerCase","countLetters","countVowels","split","letter","countConsonants","countWords","verifiers","indexOf","vowels","Set","size","firstLetter","some","index","test","countAccents","syllableDependencyVerifier","syllables","syllable","_","isAcronym","stressSyllableDependencyVerifier","stress","Math","max","updatedAt","separateSyllables","replace","getDocQueryFunction","path","docId","async","log","getCurrentDateTime","docRef","doc","firestore","getDoc","data","useGetFirebaseDoc","options","useQuery","queryKey","queryFn","useTDResource","resourceName","enabled","getUrl","useBaseUrl","query","res","fetch","json","isEmpty","useTDResourceNonCollection"],"sourceRoot":""}