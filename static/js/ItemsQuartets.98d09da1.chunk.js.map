{"version":3,"file":"static/js/ItemsQuartets.98d09da1.chunk.js","mappings":"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","sources":["hooks/useGetFirebaseDoc.ts","hooks/useResourceFirebaseData.ts","hooks/useUpdateFirebaseDoc.tsx","pages/Items/ItemsQuartets.tsx","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts"],"sourcesContent":["import { doc, getDoc } from 'firebase/firestore';\nimport { firestore } from 'services/firebase';\n\nimport { QueryKey, useQuery, UseQueryOptions } from '@tanstack/react-query';\nimport { getCurrentDateTime } from 'utils';\n\nexport function getDocQueryFunction<TQueryFnData>(path: string, docId: string) {\n  return async () => {\n    console.log(`%cQuerying ${path}/${docId} from firebase: ${getCurrentDateTime()}`, 'color: #f0f');\n    const docRef = doc(firestore, `${path}/${docId}`);\n    const querySnapshot = await getDoc(docRef);\n    return (querySnapshot.data() ?? {}) as TQueryFnData;\n  };\n}\n\nexport function useGetFirebaseDoc<TQueryFnData, TData = TQueryFnData>(\n  path: string,\n  docId: string,\n  options?: Omit<UseQueryOptions<any, Error, TData, QueryKey>, 'queryKey'>\n) {\n  return useQuery<TQueryFnData, Error, TData, QueryKey>({\n    queryKey: ['firebase', path, docId],\n    queryFn: getDocQueryFunction<TQueryFnData>(path, docId),\n    ...options,\n  });\n}\n","import { App } from 'antd';\nimport { cloneDeep, isEmpty } from 'lodash';\nimport { useMemo, useState } from 'react';\n\nimport { useQueryClient } from '@tanstack/react-query';\n\nimport { useGetFirebaseDoc } from './useGetFirebaseDoc';\nimport { useTDResource } from './useTDResource';\nimport { useUpdateFirebaseDoc } from './useUpdateFirebaseDoc';\nimport { deserializeFirebaseData, serializeFirebaseData } from 'utils';\n\nexport type UseResourceFirebaseDataProps = {\n  tdrResourceName: string;\n  firebaseDataCollectionName: string;\n  serialize?: boolean;\n};\n\nexport type UseResourceFirebaseDataReturnType<TDRData> = {\n  data: Dictionary<TDRData>;\n  isLoading: boolean;\n  error: ResponseError;\n  firebaseData: Dictionary<TDRData> | undefined;\n  isSaving: boolean;\n  save: () => void;\n  addEntryToUpdate: (id: string, item: TDRData) => void;\n  entriesToUpdate: Dictionary<TDRData>;\n  isDirty: boolean;\n};\n\n/**\n * Custom hook that fetches and manages data from both TDR (The Daily Refactor) and Firebase.\n * It merges the data from both sources and provides functions to update and save the data.\n *\n * @template TDRData - The type of data fetched from TDR.\n * @template TFirebaseData - The type of data fetched from Firebase.\n *\n * The hook return object containing the merged data, loading state, error, and functions to update and save the data.\n */\nexport function useResourceFirebaseData<TDRData = PlainObject, TFirebaseData = TDRData>({\n  tdrResourceName,\n  firebaseDataCollectionName,\n  serialize,\n}: UseResourceFirebaseDataProps): UseResourceFirebaseDataReturnType<TDRData> {\n  const { notification } = App.useApp();\n  const queryClient = useQueryClient();\n\n  const tdrQuery = useTDResource<TDRData>(tdrResourceName);\n  const firebaseQuery = useGetFirebaseDoc<Dictionary<TFirebaseData>, Dictionary<TDRData>>(\n    'data',\n    firebaseDataCollectionName,\n    {\n      select: serialize ? deserializeFirebaseData : undefined,\n    }\n  );\n\n  // Keeps track of items that have been modified\n  const [modifiedEntries, setModifiedEntries] = useState<Dictionary<TDRData>>({});\n\n  const mutation = useUpdateFirebaseDoc('data', firebaseDataCollectionName, {\n    onSuccess: () => {\n      notification.success({\n        message: `${firebaseDataCollectionName} updated`,\n      });\n      queryClient.refetchQueries({\n        queryKey: ['firebase', 'data', firebaseDataCollectionName],\n      });\n      setModifiedEntries({});\n    },\n    onError: (error) => {\n      notification.error({\n        message: `${firebaseDataCollectionName} update failed`,\n        description: error.message,\n      });\n    },\n  });\n\n  const data = useMemo(() => {\n    if (tdrQuery.isLoading || firebaseQuery.isLoading || mutation.isPending) return {};\n    console.log(`%cMerging ${tdrResourceName}+${firebaseDataCollectionName} data...`, 'color: #f0f');\n    return cloneDeep({\n      ...(tdrQuery.data ?? {}),\n      ...(firebaseQuery.data ?? {}),\n      ...modifiedEntries,\n    });\n  }, [\n    tdrResourceName,\n    firebaseDataCollectionName,\n    tdrQuery.data,\n    firebaseQuery.data,\n    tdrQuery.isLoading,\n    firebaseQuery.isLoading,\n    mutation.isPending,\n    modifiedEntries,\n  ]);\n\n  const isDirty = !isEmpty(modifiedEntries);\n  const addEntryToUpdate = (id: string, item: TDRData) => {\n    setModifiedEntries((prev) => ({ ...prev, [id]: item }));\n  };\n\n  const firebaseData = firebaseQuery.data;\n\n  const save = () => {\n    mutation.mutate(serialize ? serializeFirebaseData(modifiedEntries) : modifiedEntries);\n  };\n\n  return {\n    data,\n    isLoading: tdrQuery.isLoading || firebaseQuery.isLoading,\n    error: tdrQuery.error || firebaseQuery.error,\n    firebaseData,\n    isSaving: mutation.isPending,\n    save,\n    addEntryToUpdate,\n    entriesToUpdate: modifiedEntries,\n    isDirty,\n  };\n}\n","import { doc, DocumentData, updateDoc } from 'firebase/firestore';\nimport { firestore } from 'services/firebase';\n\nimport { QueryKey, useMutation, UseMutationOptions } from '@tanstack/react-query';\n\nexport function updateQueryFunction<TData = PlainObject>(path: string, docId: string, data: TData) {\n  console.log(`%cUpdating ${path}/${docId} from firebase`, 'color: #f00');\n  const docRef = doc(firestore, `${path}/${docId}`);\n  return updateDoc(docRef, data as DocumentData);\n}\n\nexport function useUpdateFirebaseDoc<TData>(\n  path: string,\n  docId: string,\n  options: UseMutationOptions<any, Error, TData, QueryKey> = {}\n) {\n  return useMutation<any, Error, TData, QueryKey>({\n    mutationFn: async (data: TData) => updateQueryFunction<TData>(path, docId, data),\n    ...options,\n  });\n}\n","import { Layout } from 'antd';\nimport { DataLoadingWrapper } from 'components/DataLoadingWrapper';\nimport { ItemsSetsTable } from 'components/Items/ItemSetsTable';\nimport { PageLayout } from 'components/Layout';\nimport { PageSider } from 'components/Layout/PageSider';\nimport { useResourceFirebaseData } from 'hooks/useResourceFirebaseData';\nimport { isEmpty } from 'lodash';\nimport { DailyQuartetSet } from 'types';\n\nexport function ItemsQuartets() {\n  const { data, isLoading, error, isSaving, save, addEntryToUpdate, entriesToUpdate, isDirty } =\n    useResourceFirebaseData<DailyQuartetSet>({\n      tdrResourceName: 'daily-quartet-sets',\n      firebaseDataCollectionName: 'quartetSets',\n    });\n\n  return (\n    <PageLayout title=\"Items\" subtitle=\"Quartet Sets\">\n      <Layout hasSider>\n        <PageSider>\n          <>-</>\n        </PageSider>\n\n        <Layout.Content className=\"content\">\n          <DataLoadingWrapper isLoading={isLoading} error={error} hasResponseData={!isEmpty(data)}>\n            <ItemsSetsTable />\n          </DataLoadingWrapper>\n        </Layout.Content>\n      </Layout>\n    </PageLayout>\n  );\n}\n\nexport default ItemsQuartets;\n","import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n","'use client'\nimport * as React from 'react'\nimport { MutationObserver, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { noop, shouldThrowError } from './utils'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n"],"names":["getDocQueryFunction","path","docId","async","console","log","getCurrentDateTime","docRef","doc","firestore","getDoc","data","useGetFirebaseDoc","options","useQuery","queryKey","queryFn","useResourceFirebaseData","tdrResourceName","firebaseDataCollectionName","serialize","notification","App","queryClient","useQueryClient","tdrQuery","useTDResource","firebaseQuery","select","deserializeFirebaseData","undefined","modifiedEntries","setModifiedEntries","useState","mutation","useUpdateFirebaseDoc","onSuccess","success","message","refetchQueries","onError","error","description","useMemo","isLoading","isPending","cloneDeep","isDirty","isEmpty","firebaseData","isSaving","save","mutate","serializeFirebaseData","addEntryToUpdate","id","item","prev","entriesToUpdate","updateQueryFunction","updateDoc","useMutation","mutationFn","ItemsQuartets","title","subtitle","hasSider","className","hasResponseData","MutationObserver","Subscribable","constructor","client","super","this","setOptions","bindMethods","bind","reset","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","notify","type","observer","mutationKey","hashKey","state","status","onUnsubscribe","hasListeners","removeObserver","onMutationUpdate","action","getCurrentResult","variables","build","addObserver","execute","getDefaultState","isSuccess","isError","isIdle","notifyManager","context","onSettled","listeners","forEach","listener","React","result","onStoreChange","subscribe","mutateOptions","catch","noop","shouldThrowError","throwOnError","mutateAsync"],"sourceRoot":""}